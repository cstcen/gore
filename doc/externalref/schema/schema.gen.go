// Package schema provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package schema

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

// Defines values for SceneIsPublicScene.
const (
	Leaderboard      SceneIsPublicScene = "leaderboard"
	PlatformNickname SceneIsPublicScene = "platform_nickname"
	UserInfo         SceneIsPublicScene = "user_info"
)

// BaseResultResponse defines model for BaseResultResponse.
type BaseResultResponse struct {
	Code    int    `json:"code"`
	Message string `json:"message"`
}

// CharacterInfo 角色信息
type CharacterInfo struct {
	CharacterNo  *int          `json:"character_no,omitempty"`
	GameId       *string       `json:"game_id,omitempty"`
	MemberNo     *int64        `json:"member_no,omitempty"`
	Nickname     *string       `json:"nickname,omitempty"`
	PersonalData *PersonalData `json:"personal_data,omitempty"`
	ProfileImg   *string       `json:"profile_img,omitempty"`
	ProviderCd   *string       `json:"provider_cd,omitempty"`
	ProviderId   *string       `json:"provider_id,omitempty"`
	ProviderOs   *string       `json:"provider_os,omitempty"`
	RegDt        *string       `json:"reg_dt,omitempty"`
}

// CharacterNo defines model for CharacterNo.
type CharacterNo = int

// GameId defines model for GameId.
type GameId = string

// MemberNo defines model for MemberNo.
type MemberNo = int64

// Nickname defines model for Nickname.
type Nickname = string

// Nicknames 多个昵称使用逗号分隔
type Nicknames = string

// PersonalData defines model for PersonalData.
type PersonalData = []PersonalData_Item

// PersonalData_Item defines model for PersonalData.Item.
type PersonalData_Item struct {
	union json.RawMessage
}

// PutCharacterRequestBody defines model for PutCharacterRequestBody.
type PutCharacterRequestBody struct {
	PersonalData *PersonalData `json:"personal_data,omitempty"`
}

// SceneIsPublic defines model for SceneIsPublic.
type SceneIsPublic struct {
	IsPublic bool               `json:"is_public"`
	Scene    SceneIsPublicScene `json:"scene"`
}

// SceneIsPublicScene defines model for SceneIsPublic.Scene.
type SceneIsPublicScene string

// CharacterNoInPath defines model for CharacterNoInPath.
type CharacterNoInPath = CharacterNo

// GameIdInPath defines model for GameIdInPath.
type GameIdInPath = GameId

// MemberNoInPath defines model for MemberNoInPath.
type MemberNoInPath = MemberNo

// NicknamesInQuery 多个昵称使用逗号分隔
type NicknamesInQuery = Nicknames

// AsSceneIsPublic returns the union data inside the PersonalData_Item as a SceneIsPublic
func (t PersonalData_Item) AsSceneIsPublic() (SceneIsPublic, error) {
	var body SceneIsPublic
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSceneIsPublic overwrites any union data inside the PersonalData_Item as the provided SceneIsPublic
func (t *PersonalData_Item) FromSceneIsPublic(v SceneIsPublic) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSceneIsPublic performs a merge with any union data inside the PersonalData_Item, using the provided SceneIsPublic
func (t *PersonalData_Item) MergeSceneIsPublic(v SceneIsPublic) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t PersonalData_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PersonalData_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/6RUTWsUTRD+L/W+x4Z8EGKYYxTCHlzzcRFCGGpnanc7Tn+ku0dcwoBeRE+CBJTcBCHi",
	"RRFEL5I/k89/Id0zO7PJTrIhzm26nnqe6n6qah8SJbSSJJ2FaB80GhTkyIS/h0M0mDgyXdWR6+iG/pBL",
	"iED7HwYSBUEESYMDBob2cm4ohciZnBjYZEgCfer/hvoQwX9zjehcGbVzE1pQFAzWUFAnvVV2ECD3ViwV",
	"gthjEr2ZtxQV6N6CY5Ug2eXJM09sO3IjJzOqRffCX60qxzi4q0zNDIUXqo591ipa2iSbZ26TrFbSUvDc",
	"KE3GcQqYRKXh1I20l+fS0YAMFAwEWYuDyaB1hstBuE7zItslRYPfYWO86u1S4jxX7XZH9pVnTMkmhmvH",
	"lX+Di6P3F29/nBx/Onv1Ddj1Cse5sVTtlfrGiHnaUimrXKxS+8oIdGXy8hKwFq7x+7eSaTJWScziFN1M",
	"X9Yr8COPLcKt+jyjmItBO7lRz3lKJk7S2+N8RlzZ1rihQZy6djtvNqwbHo5eoNCZhyzMzy8uLbW/XTVh",
	"V/Bba083GnBTTT0c19nDt7iyvLDwYH4F2F0860541nDtkpSc2rSbiZnqxNPPhye/v559/Hl+9P3kz/H5",
	"wZfLlx9O3/06ffP68vAA2BQ/y7jFNpEr9vthdySCIMrRkz5E27d3z1ZCkjp2Pe9lPIFipzEJjcFRUMhd",
	"bdMm7eVk3apKR9Mz/g9t29YbV0ubUuM21nWoSu4plRFKCPuJZOmUzIVfH7n1Pe33AgOdofOGx/UYMsgI",
	"UzI9hSad2C037KKSnU0UMb2OfE7Qi2SeZQyUJomaQwS+AnRDW0aKvwEAAP//YkJ1oC4HAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
